(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{544:function(a,t,e){"use strict";e.r(t);var n=e(12),s=Object(n.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"什么是-html-语义化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-html-语义化"}},[a._v("#")]),a._v(" 什么是 HTML 语义化")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。\n")])])]),e("h2",{attrs:{id:"为什么要-html-语义化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要-html-语义化"}},[a._v("#")]),a._v(" 为什么要 HTML 语义化")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    1. 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构；\n\n    2. 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；\n\n    3. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；\n\n    4. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；\n\n    5. 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。\n")])])]),e("h2",{attrs:{id:"标签-title-与-alt-属性的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标签-title-与-alt-属性的区别"}},[a._v("#")]),a._v(" 标签 title 与 alt 属性的区别")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    它们都会出现一个浮层用于解释图片的相关内容。\n\n    alt属性会在图片未加载或者无法加载时在原本图片位置显示一段文字，便于用户浏览与开发者维护，搜索引擎也可以通过这个属性获取图片。\n\n    title属性可以用在任何元素上，当用户把鼠标移动到元素上时，就会出现title的内容，起到对图片说明的作用，其实质就是对图片的一种备注或者注释\n")])])]),e("h2",{attrs:{id:"iframe-的优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#iframe-的优缺点"}},[a._v("#")]),a._v(" iframe 的优缺点")]),a._v(" "),e("h3",{attrs:{id:"优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    可以跨域请求其他网站，并将网站完整展示出来\n\n    典型系统结构可以提高代码的复用性\n\n    创建一个全新的独立的宿主环境，可以隔离或者访问原生接口及对象\n\n    模块分离，若多个页面引用同一个iframe，则便于修改操作\n\n    实现广告展示的一个解决方案\n\n    若需要刷新iframe则只需要刷新框架内，不需要刷新整个页面\n")])])]),e("h3",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    iframes阻塞页面加载，影响网页加载速度，iframe加载完毕后才会触发window.onload事件，动态设置src可解决这个问题。\n\n    加载了新页面，增加了css与js文件的请求，即额外增加了HTTP请求，增加了服务器负担。\n\n    有时iframe由于页面挤占空间的原因出现滚动条，造成布局混乱。\n\n    不利于SEO，搜索引擎的爬虫无法解读iframe的页面。\n\n    有些小型的移动设备如手机等无法完全显示框架，兼容性较差。\n\n    iframe与主页面是共享链接池的，若iframe加载时用光了链接池，则会造成主页面加载阻塞。\n")])])]),e("h2",{attrs:{id:"css-盒子模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css-盒子模型"}},[a._v("#")]),a._v(" CSS 盒子模型")]),a._v(" "),e("h3",{attrs:{id:"w3c-盒模型-标准盒模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#w3c-盒模型-标准盒模型"}},[a._v("#")]),a._v(" W3C 盒模型（标准盒模型）")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    默认box-size: content-box\n    标签宽度：width: content-width + border + padding + margin\n    CSS的宽width = content-width\n")])])]),e("h3",{attrs:{id:"ie-盒模型-怪异盒模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ie-盒模型-怪异盒模型"}},[a._v("#")]),a._v(" IE 盒模型（怪异盒模型）")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    默认box-size: border-box\n    标签宽度：width: content-width + margin\n    CSS的宽width = content-width + 2 * （border + padding）\n")])])]),e("h2",{attrs:{id:"垂直居中"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#垂直居中"}},[a._v("#")]),a._v(" 垂直居中")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    1. 文本垂直居中：line-height\n    2. 元素垂直居中：\n        1. flex布局：align-items：center;\n        2. table-cell布局：vertical-align： middle;\n        3. padding： 5px 0;\n        4. position: absolute; margin: auto 0;\n")])])]),e("h2",{attrs:{id:"raba-和-opacity-的透明效果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#raba-和-opacity-的透明效果"}},[a._v("#")]),a._v(" raba 和 opacity 的透明效果")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，而rgba()只作用于元素的颜色或其背景色。\n")])])]),e("h2",{attrs:{id:"position-中-relative-和-absolute-分别相对于谁进行定位"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#position-中-relative-和-absolute-分别相对于谁进行定位"}},[a._v("#")]),a._v(" position 中,relative 和 absolute 分别相对于谁进行定位")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    relative生成相对定位的元素，相对于其正常位置进行定位。\n    absolute生成绝对定位的元素，相对于最近一级的 不是 static 的父元素来进行定位,如果没有找到的话，最终是根据body进行定位。\n")])])]),e("h2",{attrs:{id:"html5-与-css3-的新特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html5-与-css3-的新特性"}},[a._v("#")]),a._v(" HTML5 与 CSS3 的新特性")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    HTML5:\n\n    1. 语义化标签(header,footer,nav,section,article,aside,details,summary,dialog等)\n\n    2. 增强型表单(HTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证。color,date,email等；新增表单属性（placeholder,required,step等）；)\n\n    3. 视频与音频(audio支持音频：mp3，ogg，wav；video支持视频：mp4，webm，ogg)\n\n    4. canvas绘图：需用JavaScript进行绘制\n\n    5. svg绘图：使用XML描述2d图形的语言\n\n    6. 地理定位\n\n    7. 拖放API：dragstart*1 + drag*n + dragend*1\n\n    8. webworker\n\n    9. Web Storage：localstorage与sessionstorage\n\n    10. WebSocket\n\n    CSS3:\n\n    1、新增选择器 p:nth-child（n）{color: rgba（255, 0, 0, 0.75）}\n\n    2、弹性盒模型 display: flex;\n\n    3、多列布局 column-count: 5;\n\n    4、媒体查询 @media （max-width: 480px） {.box: {column-count: 1;}}\n\n    5、个性化字体 @font-face{font-family:BorderWeb;src:url（BORDERW0.eot）；}\n\n    6、颜色透明度 color: rgba（255, 0, 0, 0.75）；\n\n    7、圆角 border-radius: 5px;\n\n    8、渐变 background:linear-gradient（red, green, blue）；\n\n    9、阴影 box-shadow:3px 3px 3px rgba（0, 64, 128, 0.3）；\n\n    10、倒影 box-reflect: below 2px;\n\n    11、文字装饰 text-stroke-color: red;\n\n    12、文字溢出 text-overflow:ellipsis;\n\n    13、背景效果 background-size: 100px 100px;\n\n    14、边框效果 border-image:url（bt_blue.png） 0 10;\n\n    15、旋转 transform: rotate（20deg）；\n\n    16、倾斜 transform: skew（150deg, -10deg）；\n\n    17、位移 transform:translate（20px, 20px）；\n\n    18、缩放 transform: scale（。5）；\n\n    19、平滑过渡 transition: all .3s ease-in .1s;\n\n    20、动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;\n")])])]),e("h2",{attrs:{id:"bfc-是什么-块级格式化上下文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bfc-是什么-块级格式化上下文"}},[a._v("#")]),a._v(" BFC 是什么（块级格式化上下文）")]),a._v(" "),e("h3",{attrs:{id:"定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[a._v("#")]),a._v(" 定义")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。\n")])])]),e("h3",{attrs:{id:"触发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#触发"}},[a._v("#")]),a._v(" 触发：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    1. body根元素\n    2. 浮动元素（float出现除none之外的值）\n    3. 绝对定位（position出现fixed与absolute）\n    4. display（inline-block,table-cells,flex）\n    5、overflow（除visible以外的的值，如hidden,auto,scroll）\n")])])]),e("h3",{attrs:{id:"特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[a._v("#")]),a._v(" 特点：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    1. BFC内部块级盒子垂直排列。\n    2. box的垂直方向距离由margin决定，属于同一个BFC的两个相邻box的margin会发生重叠。\n    3. 每个元素的marginbox的左边，与包含块borderbox的左边相接触。\n    4. BFC的区域不会与floatbox接触。\n    5. BFC是页面上一个隔离的独立容器，容器内子元素不会影响外部，外部元素也不会影响内部。\n    6. 计算BFC高度时，浮动元素也参与计算。\n")])])]),e("h2",{attrs:{id:"常见兼容性问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见兼容性问题"}},[a._v("#")]),a._v(" 常见兼容性问题")]),a._v(" "),e("h2",{attrs:{id:"js-的数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-的数据类型"}},[a._v("#")]),a._v(" JS 的数据类型")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    Number, String, Boolean, Symbol, null, undefined, Bigint, Object(Array, Date, function)\n")])])]),e("h2",{attrs:{id:"判断一个值是什么类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#判断一个值是什么类型"}},[a._v("#")]),a._v(" 判断一个值是什么类型")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    1. typeof\n\n    2. instantof\n\n    3. constructor\n\n    4. Object.prototype.toString（最准确） 用法：必须使用Object.prototype.toString.call来强制执行，某些类型中实现了自己的toString方法\n")])])]),e("h2",{attrs:{id:"null-和-undefined-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#null-和-undefined-的区别"}},[a._v("#")]),a._v(" null 和 undefined 的区别")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    null 表示一个值被定义了，定义为“空值”；变量是空对象\n    undefined 表示根本不存在定义。\n    在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。\n    null值则是表示空对象指针。\n")])])]),e("h2",{attrs:{id:"判断一个变量是不是数组-不能用-typeof"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#判断一个变量是不是数组-不能用-typeof"}},[a._v("#")]),a._v(" 判断一个变量是不是数组（不能用 typeof）")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    1. Object.prototype.toString.call(arr)\n\n    2. Array.isArray()高版本浏览器下最好用\n")])])]),e("h2",{attrs:{id:"箭头函数有哪些特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数有哪些特点"}},[a._v("#")]),a._v(" 箭头函数有哪些特点")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    1. this指向，this永远等于外层函数的this\n\n    2. 不可作为构造函数\n\n    3. arguments对象：箭头函数中没有定义arguments关键字，跟this一样，也是由词法决定的，也就是会解析到外层函数的arguments，如果你想获取箭头函数自己的参数对象，可以用 ES6 的剩余参数（...操作符）特性\n\n    4. 隐式返回值：如果箭头函数只包含一个表达式，那么就可以省略函数体的花括号和return语句，并且这个表达式会被当作返回值。\n\n    5. 类成员方法：作为类的成员方法，箭头函数的this指向永远指向类的实例对象\n")])])]),e("h2",{attrs:{id:"new-操作符具体做了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new-操作符具体做了什么"}},[a._v("#")]),a._v(" new 操作符具体做了什么")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    1. 创建一个空对象\n\n    2. 链接到原型：把 obj 的proto 指向构造函数Func的原型对象 prototype，此时便建立了 obj 对象的原型链：obj->Func.prototype->Object.prototype->null\n\n    3. 绑定this值（让Func中的this指向obj，并执行Func的函数体。）\n\n    4. 返回新对象：判断Func的返回值类型：如果无返回值 或者 返回一个非对象值，则将 obj 作为新对象返回；否则会将 result 作为新对象返回。\n")])])]),e("h2",{attrs:{id:"document-write-和-innerhtml-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#document-write-和-innerhtml-的区别"}},[a._v("#")]),a._v(" document.write 和 innerHTML 的区别")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    1.write是DOM方法,向文档写入HTML表达式或JavaScript代码，可列出多个参数，参数被顺序添加到文档中 ；innerHTML是DOM属性,设置或返回调用元素开始结束标签之间的HTML元素。\n\n    2.两者都可向页面输出内容,innerHTML比document.write更灵活。\n\n        当文档加载时调用document.write直接向页面输出内容，文档加载结束后调用document.write输出内容会重写整个页面。\n        通常按照两种的方式使用 write() 方法：一是在使用该方在文档中输出 HTML，二是在调用该方法的的窗口之外的窗口、框架中产生新文档（务必使用close关闭文档）。\n        在读模式下，innerHTML属性返回与调用元素的所有子节点对应的HTML标记，在写模式下，innerHTML会根据指定的值创建新的DOM树替换调用元素原先的所有子节点。\n\n    3.两者都可动态包含外部资源如JavaScript文件\n\n        通过document.write插入<script>元素会自动执行其中的脚本；\n        大多数浏览器中，通过innerHTML插入<script>元素并不会执行其中的脚本。\n")])])]),e("h2",{attrs:{id:"什么是-ajax-过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-ajax-过程"}},[a._v("#")]),a._v(" 什么是 Ajax 过程")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    创建XMLHttpRequest对象,也就是创建一个异步调用对象.\n\n    创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.\n\n    设置响应HTTP请求状态变化的函数.\n\n    发送HTTP请求.\n\n    获取异步调用返回的数据.\n\n    使用JavaScript和DOM实现局部刷新.\n\n")])])]),e("h2",{attrs:{id:"javascript-同源策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-同源策略"}},[a._v("#")]),a._v(" JavaScript 同源策略")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    JS只能与同一个域中的页面进行通讯.如:运行在 http://domain:port/app1/page.html;上的脚本不能和http://domain:port/app3/page.html;的浏览器窗口或iframe 进行交互.不能访问它的cookie,接收它的HTTP响应等(但它可以向任何其他源发送HTTP请求);AJAX 和 webservice 也受此策略管束.这种手段就叫同源策略;\n    两个脚本被认为是同源的条件是:\n\n    协议相同(比如都是http://)\n    端口相同(通常都是80)\n    域名相同\n")])])]),e("h2",{attrs:{id:"闭包和闭包常用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包和闭包常用场景"}},[a._v("#")]),a._v(" 闭包和闭包常用场景")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    闭包就是在函数内部创建另一个函数\n\n    ①函数嵌套函数\n\n    ②函数内部可以引用函数外部的参数和变量\n\n    ③参数和变量不会被垃圾回收机制回收\n\n    使用场景：\n\n    1. setTimeout\n    2. 回调\n    3. 函数防抖\n    /*\n    * fn [function] 需要防抖的函数\n    * delay [number] 毫秒，防抖期限值\n    */\n    function debounce(fn,delay){\n        let timer = null\n        //借助闭包\n        return function() {\n            if(timer){\n                clearTimeout(timer) //进入该分支语句，说明当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时\n                timer = setTimeOut(fn,delay)\n            }else{\n                timer = setTimeOut(fn,delay) // 进入该分支说明当前并没有在计时，那么就开始一个计时\n            }\n        }\n    }\n    4. 封装私有变量\n\n    好处\n\n    ①保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突\n\n    ②在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）\n\n    ③匿名自执行函数可以减少内存消耗\n\n    坏处\n\n    ①其中一点上面已经有体现了，就是被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；\n\n    ②其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响\n")])])]),e("h2",{attrs:{id:"javascript-的回收机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的回收机制"}},[a._v("#")]),a._v(" JavaScript 的回收机制")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    标记清除\n\n    当变量进入执行环境是，就会被标记上“进入环境”，从逻辑上讲，被标记上“进入环境”的变量所指向的内存是永远不会被回收的。当某个变量离开执行环境时，就会被标上“离开环境”。被标记为“离开环境”的变量则是可以回收的。\n\n    引用计数\n\n    这是一种不太常见的回收方式。引用计数法就是同级引用类型声明后被引用的次数，当次数为0时，该变量就会被回收。\n\n    // 有缺陷的引用计数，内存泄漏\n    function func() {\n        let f = {};\n        let g = {};\n        f.prop = g;\n        g.prop = f;\n        // 由于 f 和 g 相互引用，计数永远不为0\n    }\n\n")])])]),e("h2",{attrs:{id:"mvvm-开发模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-开发模式"}},[a._v("#")]),a._v(" MVVM 开发模式")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    Model——即模型。模型一般都有很好的可复用性，统一管理一些我们需要使用的数据。\n\n    View——就是存放视图使用的。\n\n    Controller——控制器它负责处理View和Model的事件。\n\n    ViewModel——相比较于MVC新引入的视图模型。是视图显示逻辑、验证逻辑、网络请求等代码存放的地方。\n")])])]),e("h2",{attrs:{id:"v-if-和-v-show-有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-show-有什么区别"}},[a._v("#")]),a._v(" v-if 和 v-show 有什么区别")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    v-if根据判断条件的真假选择是否进行元素的渲染\n\n    v-show根据判断条件的真假选择是否进行元素的显示，v-show是控制了display样式，true为block，false为none\n")])])]),e("h2",{attrs:{id:"vuex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[a._v("#")]),a._v(" Vuex")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    Vuex 是一个专为 Vue.js 应用程序开发的`状态管理模式`。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n    你有几个数据，几个操作，在多个组件上都需要使用，如果每个组件都去调用都是写，就会很麻烦，代码又臭又长。当然 如果没有大量的操作和数据需要在多个组件内使用的话呢，其实也就可以不用这个Vuex了。\n")])])]),e("h2",{attrs:{id:"spa-单页面应用的理解及优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spa-单页面应用的理解及优缺点"}},[a._v("#")]),a._v(" SPA 单页面应用的理解及优缺点")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    SPA 是一种特殊的 Web 应用，是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的。它将所有的活动局限于一个 Web 页面中，仅在该 Web 页面初始化时加载相应的 HTML 、 JavaScript 、 CSS 。一旦页面加载完成， SPA 不会因为用户的操作而进行页面的重新加载或跳转，而是利用 JavaScript 动态的变换 HTML（采用的是 div 切换显示和隐藏），从而实现UI与用户的交互。在 SPA 应用中，应用加载之后就不会再有整页刷新。相反，展示逻辑预先加载，并有赖于内容Region（区域）中的视图切换来展示内容。\n\n    1. 优点\n\n    1) 有良好的交互体验\n\n    能提升页面切换体验，用户在访问应用页面是不会频繁的去切换浏览页面，从而避免了页面的重新加载；\n\n    2) 前后端分离开发\n\n    单页Web应用可以和 RESTful 规约一起使用，通过 REST API 提供接口数据，并使用 Ajax 异步获取，这样有助于分离客户端和服务器端工作。更进一步，可以在客户端也可以分解为静态页面和页面交互两个部分；\n\n    3) 减轻服务器压力\n\n    服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；\n\n    4) 共用一套后端程序代码\n\n    不用修改后端程序代码就可以同时用于 Web 界面、手机、平板等多种客户端；\n\n    2. 缺点：\n\n    1) SEO难度较高\n\n    由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势，所以如果你的站点对SEO很看重，且要用单页应用，那么就做些静态页面给搜索引擎用吧；\n\n    2) 前进、后退管理\n\n    由于单页Web应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理，当然此问题也有解决方案，比如利用URI中的散列+iframe实现；\n\n    3) 初次加载耗时多\n\n    为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。所以必须对JavaScript及CSS代码进行合并压缩处理；\n\n")])])]),e("h2",{attrs:{id:"class-和-style-如何动态绑定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#class-和-style-如何动态绑定"}},[a._v("#")]),a._v(" class 和 style 如何动态绑定")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    <div :style=\"{height: xx + 'px',fontSize: xx + 'px'}\" :class = \"div1\"></div>\n    div1 = {\n        //一些样式\n    }\n")])])]),e("h2",{attrs:{id:"怎样理解-vue-的单向数据流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#怎样理解-vue-的单向数据流"}},[a._v("#")]),a._v(" 怎样理解 vue 的单向数据流")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    1. Vue 的单向数据流：指数据一般从父组件传到子组件，子组件没有权利直接修改父组件传来的数据，即子组件从 props 中直接获取的数据，只能请求父组件修改数据再传给子组件。父级属性值的更新会下行流动到子组件中。\n\n    2. 为什么不能子组件直接修改父组件传来的值呢？父组件的值可能会不断发生变化，那么如果我们子组件对父组件传来的值比如说 props 有一个 number，子组件收到了 number=1，在收到后，子组件直接改变number 的值为 5，去做些事情，但还未做时父组件数据更新了，传过来一个值 3，也就是说子组件刚将其变为 5，父组件又把它变成了 3，可能影响子组件的使用。说的官方一些，就是父组件的值更新时，子组件中 props 的值也会发生更新。\n\n    3. 在子组件中直接用 v-model 绑定父组件传过来的数据是不合理的，如果希望修改父组件传给子组件的值：\n\n    （1）在子组件 data 中创建一个变量获取 props 中的值，再改变这个 data 中的值。\n\n    （2）子组件使用 $emit 发出一个事件，让父组件接收去修改这个值。\n")])])]),e("h2",{attrs:{id:"computed-和-watch-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-的区别"}},[a._v("#")]),a._v(" computed 和 watch 的区别")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    1、功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。\n\n    2、是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。\n\n    3、是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。\n\n    4、computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）\n\n    5、使用场景：computed----当一个属性受多个属性影响的时候，使用computed-----购物车商品结算。watch–当一条数据影响多条数据的时候，使用watch-----搜索框.\n")])])]),e("h2",{attrs:{id:"vue-生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-生命周期"}},[a._v("#")]),a._v(" vue 生命周期")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    beforeCreate( 创建前 )\n\n    在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据。\n\n    created ( 创建后 ）\n\n    实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化，el没有。 然而，挂在阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成\n\n    beforeMount\n\n    挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。\n\n    mounted\n\n    挂在完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。\n\n    beforeUpdate\n\n    在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程\n\n    updated（更新后）\n\n    在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用\n\n    beforeDestroy（销毁前）\n\n    在实例销毁之前调用，实例仍然完全可用，\n\n    这一步还可以用this来获取实例，\n\n    一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件\n\n    destroyed（销毁后）\n\n    在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用\n")])])]),e("h2",{attrs:{id:"vue-父子组件生命周期钩子函数的执行顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-父子组件生命周期钩子函数的执行顺序"}},[a._v("#")]),a._v(" vue 父子组件生命周期钩子函数的执行顺序")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    初始化\n\n    父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted\n\n    子组件更新过程\n\n    父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated\n\n    父组件更新过程\n\n    父 beforeUpdate -> 父 updated\n\n    销毁过程\n\n    父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed\n")])])]),e("h2",{attrs:{id:"父组件可以监听到子组件的生命周期吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#父组件可以监听到子组件的生命周期吗"}},[a._v("#")]),a._v(" 父组件可以监听到子组件的生命周期吗")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    1. 使用on和emit\n\n    子组件emit触发一个事件，父组件on监听相应事件\n\n    2. hook钩子函数\n\n    使用vue hook生命周期钩子函数。\n\n")])])]),e("h2",{attrs:{id:"在-vue-中如何实现对象和数组的监听"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在-vue-中如何实现对象和数组的监听"}},[a._v("#")]),a._v(" 在 vue 中如何实现对象和数组的监听")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    <template>\n        <div id=\"test\">\n            <button @click=\"changeAge\">change</button>\n        </div>\n    </template>\n    <script>\n    export default {\n        name: 'test',\n        data () {\n            return {\n            user: { id: 1, name: '李四', age: 14, sex: '男' }\n            }\n        },\n        watch: {\n            user: {\n            handler: function (val) {\n                console.log(val)\n            },\n            deep: true\n            }\n        },\n        methods: {\n            changeAge () {\n            this.user.age = 15\n            }\n        }\n    }\n    <\/script>\n\n    通过watch中的deep属性，监听对象的所有属性，当属性值改变的时候，watch将会被打印,但是这样消耗会很大\n\n    当然，也可以只监听对象的某个属性\n\n    watch: {\n     'user.age' () {\n       console.log(1111)\n     }\n   }\n")])])]),e("h2",{attrs:{id:"vue-是如何实现数据双向绑定的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-是如何实现数据双向绑定的"}},[a._v("#")]),a._v(" vue 是如何实现数据双向绑定的")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。是通过Object.defineProperty()来实现数据劫持的。它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举。\n")])])]),e("h2",{attrs:{id:"虚拟-dom-的优缺点和实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-的优缺点和实现原理"}},[a._v("#")]),a._v(" 虚拟 dom 的优缺点和实现原理")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    优点：\n\n    保证性能下限：虚拟dom可以经过diff算法找出最小差异，然后批量进行patch，这种操作虽然比不上手动优化，但是比粗暴的dom操作性能要好很多\n\n    无需手动操作dom：虚拟dom的diff和patch都是在一次更新中自动进行的，无需手动操作，提高开发效率\n\n    跨平台：虚拟dom本质上是js的一个对象，而dom本身需平台强相关，相比之下虚拟dom可以更方便地跨平台操作，例如服务器渲染，移动端开发等。\n\n    缺点：\n\n    无法进行极致优化：在一些性能要求极高的应用中虚拟dom无法进行针对性的优化。\n\n")])])]),e("h2",{attrs:{id:"vue-中的-key-有什么作用-diff-算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-中的-key-有什么作用-diff-算法"}},[a._v("#")]),a._v(" vue 中的 key 有什么作用（diff 算法）")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    key的作用主要是为了高效的更新虚拟DOM，相当于给数组的每个元素都绑定唯一的key，如果某个key对应的元素发生变化，直接更新对应的dom就行，不用全部更新一遍。\n\n    key在操作中的作用：辅助判断新旧vdom节点在逻辑上是不是同一个对象；比如说数组里插入了一项，这就是很经典的例子\n\n    优点\n\n    1、准确。因为key的特性是唯一性。所以如果不加key，采用index的标记法，那么vue会选择复用同类型节点(Vue的就地更新策略)，导致之前节点的状态被保留下来,会产生一系列的bug.\n\n    2、快速。在元素list一直变化的情况下，key值设置唯一时，能很精确找到/找不到变更元素，若使用index标记，要遍历vnode，时间长。\n")])])]),e("h2",{attrs:{id:"vue-常见优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-常见优化"}},[a._v("#")]),a._v(" vue 常见优化")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    代码优化\n    1. 代码模块化 尽量把重复性高的地方封装成组件减少重复代码\n    2. 前端for循环设置key\n    3. 路由懒加载\n    4. 在对应的生命周期做正确的事\n    打包优化\n    1. 减少图片使用\n    2. 按需引入，咱们使用的一些第三方库可以通过按需引入的方式加载。避免引入不需要使用的部分，无端增加项目体积。比如在使用element-ui库的时候，可以只引入需要用到的组件。\n")])])]),e("h2",{attrs:{id:"vue3-0-的新特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0-的新特性"}},[a._v("#")]),a._v(" vue3.0 的新特性")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    性能\n\n    双向响应原理由Object.defineProperty改为基于ES6的Proxy，使其颗粒度更大，速度更快，且消除了之前存在的警告；\n\n    重写了 Vdom ，突破了 Vdom 的性能瓶颈\n\n    进行了模板编译的优化\n\n    进行了更加高效的组件初始化\n\n    Tree-Shaking 的支持\n\n    支持了 tree-shaking （剪枝）：像修剪树叶一样把不需要的东西给修剪掉，使 Vue3 的体积更小。\n\n    需要的模块才会打入到包里，优化后的 Vue3.0 的打包体积只有原来的一半（13kb）。哪怕把所有的功能都引入进来也只有23kb，依然比 Vue2.x 更小。像 keep-alive 、 transition 甚至 v-for 等功能都可以按需引入。\n\n    Composition API\n\n    composition-api 是一个 Vue3 中新增的功能，它的灵感来自于 React Hooks ，是比 mixin 更强大的存在。\n\n    Fragments\n\n    不再限制 template 只有一个根节点。\n\n    render函数也可以返回数组了，有点像 React.Fragments\n\n    Better TypeScript Support\n\n    更好的类型推导，使得 Vue3 把 TypeScript 支持得非常好\n\n    Custom Renderer API\n\n    实现用DOM的方式进行 WebGL 编程\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);